#!/usr/bin/env python3
"""
Step 3: Prove candidate equivalences using SMT-based k-induction.

Takes candidates from simulation and uses Z3 to formally prove equivalences
using the SMT2 model generated by Yosys.
"""

import sys
import subprocess
import tempfile
import json
from pathlib import Path
from parse_yosys_smt2 import YosysSMT2Parser

def parse_smt2_signals(smt2_file):
    """Extract signal definitions from Yosys SMT2 file."""

    signals = {}

    with open(smt2_file, 'r') as f:
        for line in f:
            # Look for signal name comments
            # Format: ; yosys-smt2-wire signal_name width
            if '; yosys-smt2-wire' in line:
                parts = line.strip().split()
                if len(parts) >= 3:
                    signal_name = parts[2]
                    signals[signal_name] = signal_name

            # Also look for define-fun with readable names
            if 'define-fun' in line and '|simple_mux_n' in line:
                # Extract signal name from function
                match = line.split('|simple_mux_n ')
                if len(match) > 1:
                    sig = match[1].split('|')[0].strip()
                    signals[sig] = sig

    return signals

def create_kinduction_smt_query(parser, signal_a, signal_b, k=2):
    """
    Create SMT2 k-induction query to check if signal_a ≡ signal_b.

    Uses parsed Yosys SMT2 structure.
    """

    # Get function names
    sig_a_func = parser.get_signal_function(signal_a)
    sig_b_func = parser.get_signal_function(signal_b)

    if not sig_a_func or not sig_b_func:
        return None, f"Signal not found: {signal_a if not sig_a_func else signal_b}"

    # Read base SMT2 model
    with open(parser.smt2_file, 'r') as f:
        smt2_base = f.read()

    query = f"""; K-Induction Equivalence Check
; Checking: {signal_a} ≡ {signal_b}
; Module: {parser.module_name}
; Induction depth k = {k}
;
; Strategy:
;   - Assume signals equal for k cycles (antecedent)
;   - Try to make them differ at cycle k (negate consequent)
;   - If UNSAT → proven equivalent!

; Include base model
{smt2_base}

; Declare states for k+1 time steps
"""

    # Declare state variables
    for t in range(k + 1):
        query += f"(declare-const s{t} {parser.state_type})\n"

    query += "\n; Apply design assumptions (from assume statements)\n"
    # Apply assumptions at all time steps
    for t in range(k + 1):
        query += f"(assert ({parser.get_assumption_function()} s{t}))\n"

    query += "\n; Not in reset (to see steady-state behavior)\n"
    rst_func = parser.get_signal_function('rst')
    if rst_func:
        for t in range(k + 1):
            query += f"(assert (= ({rst_func} s{t}) false))\n"

    query += "\n; Apply state transitions\n"
    # Link states via transition function
    for t in range(k):
        query += f"(assert ({parser.get_transition_function()} s{t} s{t+1}))\n"

    query += "\n; K-Induction: Force signals equal for k cycles (antecedent)\n"
    # Force signals equal for k cycles
    for t in range(k):
        query += f"(assert (= ({sig_a_func} s{t}) ({sig_b_func} s{t})))\n"

    query += "\n; Try to make signals differ at cycle k (negate consequent)\n"
    query += f"(assert (not (= ({sig_a_func} s{k}) ({sig_b_func} s{k}))))\n"

    query += "\n; Check satisfiability\n"
    query += "; If UNSAT → equivalence PROVEN!\n"
    query += "; If SAT → not equivalent (or k too small)\n"
    query += "(check-sat)\n"

    return query, None

def check_equivalence_with_z3(query, timeout=30, save_query_to=None):
    """Run Z3 on SMT query."""

    # Write query to temp file
    if save_query_to:
        query_file = save_query_to
        with open(query_file, 'w') as f:
            f.write(query)
        delete_after = False
    else:
        with tempfile.NamedTemporaryFile(mode='w', suffix='.smt2', delete=False) as f:
            f.write(query)
            query_file = f.name
        delete_after = True

    try:
        result = subprocess.run(
            ['z3', '-smt2', query_file],
            capture_output=True,
            text=True,
            timeout=timeout
        )

        if delete_after:
            Path(query_file).unlink()

        # Parse result
        stdout_lower = result.stdout.lower()
        if 'unsat' in stdout_lower:
            return 'EQUIV'
        elif 'sat' in stdout_lower and 'unsat' not in stdout_lower:
            return 'NOT_EQUIV'
        else:
            return f'UNKNOWN ({result.stdout.strip()[:50]})'

    except subprocess.TimeoutExpired:
        if delete_after:
            Path(query_file).unlink()
        return 'TIMEOUT'
    except FileNotFoundError:
        if delete_after:
            Path(query_file).unlink()
        return 'Z3_NOT_FOUND'

def main():
    if len(sys.argv) != 3:
        print("Usage: smt_prove_equivalences.py <candidates.json> <smt2_file>")
        print("")
        print("Example:")
        print("  smt_prove_equivalences.py output/simple_mux_candidates.json output/simple_mux_smt.smt2")
        print("")
        print("Proves candidate equivalences using SMT k-induction")
        sys.exit(1)

    candidates_file = Path(sys.argv[1])
    smt2_file = Path(sys.argv[2])

    if not candidates_file.exists():
        print(f"ERROR: Candidates file not found: {candidates_file}")
        sys.exit(1)

    if not smt2_file.exists():
        print(f"ERROR: SMT2 file not found: {smt2_file}")
        sys.exit(1)

    print("=" * 80)
    print("STEP 3: SMT-BASED K-INDUCTION EQUIVALENCE CHECKING")
    print("=" * 80)
    print()

    # Load candidates
    with open(candidates_file, 'r') as f:
        data = json.load(f)
        candidate_classes = data.get('candidates', [])

    print(f"Loaded {len(candidate_classes)} equivalence class candidates")
    print()

    # Check for Z3
    try:
        subprocess.run(['z3', '--version'], capture_output=True, check=True)
    except (FileNotFoundError, subprocess.CalledProcessError):
        print("ERROR: Z3 not found. Install with: sudo apt install z3")
        sys.exit(1)

    # Parse SMT2 file structure
    print(f"Parsing SMT2 structure...")
    parser = YosysSMT2Parser(smt2_file)
    print(f"  Module: {parser.module_name}")
    print(f"  State type: {parser.state_type}")
    print(f"  Found {len(parser.signals)} signals")
    print()

    # Prove each candidate equivalence
    proven_equivalences = []
    k = 2  # K-induction depth

    print(f"Checking equivalence candidates (k={k})...")
    print("-" * 80)

    for eq_class in candidate_classes:
        if len(eq_class) < 2:
            continue

        # Check all pairs in equivalence class
        for i in range(len(eq_class)):
            for j in range(i + 1, len(eq_class)):
                signal_a = eq_class[i]
                signal_b = eq_class[j]

                print(f"\nChecking: {signal_a} ≡ {signal_b}")

                # Create k-induction query
                query, error = create_kinduction_smt_query(parser, signal_a, signal_b, k)

                if error:
                    print(f"  Error: {error}")
                    continue

                # Check with Z3 (save first query for debugging)
                save_path = None
                if i == 0 and j == 1:  # Save first query
                    save_path = f"output/debug_query_{signal_a}_{signal_b}.smt2"

                result = check_equivalence_with_z3(query, timeout=30, save_query_to=save_path)

                if save_path:
                    print(f"  (Saved query to: {save_path})")

                print(f"  Result: {result}")

                if result == 'EQUIV':
                    proven_equivalences.append((signal_a, signal_b))
                    print(f"  ✓ PROVEN EQUIVALENT!")

    print()
    print("=" * 80)
    print(f"SUMMARY: Proven {len(proven_equivalences)} equivalences")
    print("=" * 80)

    for sig_a, sig_b in proven_equivalences:
        print(f"  {sig_a} ≡ {sig_b}")

    # Save proven equivalences
    output_file = candidates_file.parent / "proven_equivalences.json"
    with open(output_file, 'w') as f:
        json.dump({
            'proven_equivalences': proven_equivalences,
            'k': k,
            'method': 'SMT k-induction with Z3'
        }, f, indent=2)

    print()
    print(f"✓ Saved to: {output_file}")
    print()
    print("Next step: Apply equivalences to optimize RTL")
    print("  python3 scripts/step4_optimize_rtl.py output/proven_equivalences.json")

if __name__ == '__main__':
    main()
